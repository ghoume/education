# Здесь рассматриваются режимы ограничения доступа данным и методам класса извне, основа механизма инкапсуляция
# Также здесь посмотрим как происходит обращение к закрытым (приватным) свойствам через специальные методы: геттеры и сеттеры
# Разовьем этот подход и поговорим о создании объектов-свойств (property) класса и дескрипторах.

class Point_1: 
    """Инкапсуляция, рассмотрим точку на плоскости"""
    def __init__(self, x: int = 0, y: int = 0): 
        self.x = x; self.y = y


# Создаем экземпляр класса
pt = Point_1(1, 2)
# Теперь имеем доступ к его локальным переменным
print(pt.x, pt.x)
# А, следовательно, можем менять их вне класса
pt.x = 10
pt.y = 20
print(pt.x, pt.y)

# Чтобы программист не мог произвольным образом задавать атрибуты их следует «закрывать» от вмешательства извне. В Python возможны следующие варианты доступа к данным:
# <имя атрибута> (без одного или двух подчеркиваний вначале) – публичное свойство (public);
# _<имя атрибута> (с одним подчеркиванием) – режим доступа protected (можно обращаться только внутри класса и во всех его дочерних классах)
# __<имя атрибута> (с двумя подчеркиваниями) – режим доступа private (можно обращаться только внутри класса).

# О режиме protected поговорим, когда будем рассматривать наследование классов.
# Итак, создадим в инициализаторе два приватных атрибута:

class Point_2:

    """Еще один дополнительный контроль за локальными свойствами экземпляров классов можно сделать с помощью коллекции:"""
    __slots__ = ["__x", "__y"]

    def __init__(self, x: int = 0, y: int = 0):
        self.__x = x; self.__y = y

    def setCoords(self, x, y): 
        """Но как мы тогда сможем переопределять такие свойства? Для этого в классах объявляют специальные методы, которые, обычно, начинаются с префикса set (что означает задать, установить) и далее, какое-либо имя, например, так:"""
        if Point_2.__checkValue(x) and Point_2.__checkValue(y):
            self.__x = x; self.__y = y
        else: 
            print("Координаты должны быть числами типа int")

    def getCoords(self):
        """Возвращает координаты класса x, y"""
        return self.__x, self.__y
    
    def __getattribute__(self, item):
        if item == "_Point_2__x":
            raise ValueError("Private attribute")
        else:
            return object.__getattribute__(self, item)
    
    # def __setattr__(self, key, value):
    #     """мы запрещаем изменять свойство WIDTH нашего класса. При попытке это сделать:"""
    #     if key == "WIDTH":
    #         raise AttributeError
    #     else:
    #         self.__dict__[key] = value
    
    def __getattr__(self, item):
        print("__getattr__: "+item)

    def __delattr__(self, item):
        print("__delattr__: "+item)
    
    def __checkValue(x): 
        """Продолжим совершенствовать наш класс Point. 
        Вот такие проверки корректности данных, часто реализуют в виде вспомогательных методов, которые доступны только внутри класса, то есть, их делают приватными (закрытыми). 
        Мы здесь объявили метод без параметра self, т.к. ему не нужен доступ к экземпляру класса и вызываться он будет непосредственно через класс:"""
        if isinstance(x, int):
            return True 
        return False

pt1 = Point_2()
# и теперь обратиться напрямую к этим переменным уже не получится, они стали закрытыми (приватными):
# print(pt1.__x)  # 'Point_2' object has no attribute '__x' менять и использовать их можно только внутри экземпляра класса.

# Для этого используем метод класса setCoords
pt1.setCoords(11, 22)
# Чтобы увидеть изменение данных, используем getCoords
print(pt1.getCoords())

# Такие методы в ООП называются сеттерами и геттерами. Их назначение не только передавать значения между приватными атрибутами класса, но и проверять их корректность. 
# Например, в нашем случае координаты должны быть числами. Поэтому, прежде чем обновлять значения переменных, следует проверить их тип данных. 
# Для этого можно воспользоваться функцией isinstance и записать сеттер следующим образом:

# Конечно, при большом желании мы можем обратиться и к таким свойствам и методам класса извне. В Python они шифруются по шаблону:
# _Имя класса__имя переменной
# _Имя класса__имя метода
# Например, мы можем изменить приватную переменную __x, так:
pt1._Point_2__x = 100
print(pt1.getCoords())

# Однако, без крайней необходимости так делать не нужно и двойное подчеркивание должно сигнализировать программисту, что работать с таким атрибутом нужно только через сеттеры и геттеры. 
# Иначе, возможны непредвиденные ошибки.

# При необходимости мы можем осуществлять дополнительный контроль изменения атрибутов, путем перегрузки следующих методов:
# __setattr(self, key, value)__ – автоматически вызывается при изменении свойства key класса;
# __getattribute__(self, item) – автоматически вызывается при получении свойства класса с именем item;
# __getattr__(self, item) – автоматически вызывается при получении несуществующего свойства item класса;
# __delattr__(self, item) – автоматически вызывается при удалении свойства item (не важно: существует оно или нет).

# def __getattribute__(self, item):
# Например, переопределив метод: мы не сможем извне узнать значение приватной переменной __x:
# print(pt1._Point_2__x)
# выдаст исключение.  Обратите внимание, что для всех остальных свойств мы должны вызывать этот метод базового класса, в данном случае – это класс object. 
# Иначе, мы не сможем работать с атрибутами класса.

# Далее, переопределяя метод: def __setattr__(self, key, value):
# pt.WIDTH = 5 
# сработает исключение AttributeError. А иначе, мы в экземпляре класса меняем значение свойства с именем key на значение value. 
# Обратите внимание, что внутри __setattr__ менять свойства следует только через словарь __dict__. Если записать здесь что-то вроде:
# self.__x = value, то у нас метод __setattr__ начнет рекуррентно вызываться, пока не переполнится стек вызова функций.

# Наконец, методы __delattr__ и __getattr__ можно перегрузить так:

# Еще один дополнительный контроль за локальными свойствами экземпляров классов можно сделать с помощью коллекции:
# __slots__ = ["__x", "__y"]  и при попытке создать какие-либо дополнительные локальные атрибуты:
pt.z = 1 
# возникнет ошибка. 
# И, обратите внимание, в slots можно указывать имена только локальных свойств экземпляров, записать туда имена переменных самого класса нельзя. 
# Вот такая запись приведет к ошибке:
__slots__ = ["__x", "__y", "WIDTH"]